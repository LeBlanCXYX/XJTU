# 数据库系统实验

## 实验开始部分说明

**本实验采用Opengauss6.0企业版，安装在VMWare本地虚拟机：**

![image-20240619213433555](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619213433555.png)

安装完成后进入gsql客户端：

![image-20240619213331364](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619213331364.png)

## 1、创建表和写入原始数据

### （1）通过JDBC创建表和写入原始数据 

#### （1） 代码

``````java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class Creat_table {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
        
        // Database connection parameters
        String url = "jdbc:postgresql://192.168.3.26:5432/mydb";
        String user = "java";
        String password = "xyx2003.";
        
        Connection conn = null;
        try {
            // Load the PostgreSQL driver (optional step in modern JDBC)
            Class.forName("org.postgresql.Driver");
            
            // Get a connection to the database
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("Connection established successfully!");
            
            // Create schema and tables, then insert data
            createSchemaAndInsertData(conn);
            
        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close the connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("Failed to close the connection: " + e.getMessage());
                }
            }
        }
    }
    
    // Method to create schema, tables and insert data
    public static void createSchemaAndInsertData(Connection conn) throws SQLException {
        Statement stmt = null;
        try {
            stmt = conn.createStatement();
            
            // Create new schema
            stmt.executeUpdate("CREATE SCHEMA IF NOT EXISTS gauss_db");

            // Drop existing tables if they exist in the new schema
            stmt.executeUpdate("DROP TABLE IF EXISTS gauss_db.SC");
            stmt.executeUpdate("DROP TABLE IF EXISTS gauss_db.S");
            stmt.executeUpdate("DROP TABLE IF EXISTS gauss_db.C");
            
            // Create student table in the new schema
            stmt.executeUpdate("CREATE TABLE gauss_db.S469 ("
                        + "S# CHAR(10) PRIMARY KEY,"
                        + "SNAME VARCHAR(50),"
                        + "SEX CHAR(5),"
                        + "BDATE DATE,"
                        + "HEIGHT NUMERIC(4,2),"
                        + "DORM CHAR(20)"
                        + ")");

            // Create course table in the new schema
            stmt.executeUpdate("CREATE TABLE gauss_db.C469 ("
                        + "C# CHAR(10) PRIMARY KEY,"
                        + "CNAME VARCHAR(100),"
                        + "PERIOD SMALLINT,"
                        + "CREDIT NUMERIC(3,1),"
                        + "TEACHER VARCHAR(50)"
                        + ")");

            // Create selection table in the new schema
            stmt.executeUpdate("CREATE TABLE gauss_db.SC469 ("
                        + "S# CHAR(10),"
                        + "C# CHAR(10),"
                        + "GRADE NUMERIC(4,1),"
                        + "PRIMARY KEY (S#, C#),"
                        + "FOREIGN KEY (S#) REFERENCES gauss_db.S(S#),"
                        + "FOREIGN KEY (C#) REFERENCES gauss_db.C(C#)"
                        + ")");
            
            // Insert data into student table
            stmt.executeUpdate("INSERT INTO gauss_db.S (S#, SNAME, SEX, BDATE, HEIGHT, DORM) VALUES "
                               + "('01032010', '王涛', '男', '2003-4-5', 1.72, '东 6 舍 221'),"
                               + "('01032023', '孙文', '男', '2004-6-10', 1.80, '东 6 舍 221'),"
                               + "('01032001', '张晓梅', '女', '2004-11-17', 1.58, '东 1 舍 312'),"
                               + "('01032005', '刘静', '女', '2003-1-10', 1.63, '东 1 舍 312'),"
                               + "('01032112', '董蔚', '男', '2003-2-20', 1.71, '东 6 舍 221'),"
                               + "('03031011', '王倩', '女', '2004-12-20', 1.66, '东 2 舍 104'),"
                               + "('03031014', '赵思扬', '男', '2002-6-6', 1.85, '东 18 舍 421'),"
                               + "('03031051', '周剑', '男', '2002-5-8', 1.68, '东 18 舍 422'),"
                               + "('03031009', '田菲', '女', '2003-8-11', 1.60, '东 2 舍 104'),"
                               + "('03031033', '蔡明明', '男', '2003-3-12', 1.75, '东 18 舍 423'),"
                               + "('03031056', '曹子衿', '女', '2004-12-15', 1.65, '东 2 舍 305')");

            // Insert data into course table
            stmt.executeUpdate("INSERT INTO gauss_db.C (C#, CNAME, PERIOD, CREDIT, TEACHER) VALUES "
                               + "('CS-01', '数据结构', 60, 3, '张军'),"
                               + "('CS-02', '计算机组成原理', 80, 4, '王亚伟'),"
                               + "('CS-04', '人工智能', 40, 2, '李蕾'),"
                               + "('CS-05', '深度学习', 40, 2, '崔昀'),"
                               + "('EE-01', '信号与系统', 60, 3, '张明'),"
                               + "('EE-02', '数字逻辑电路', 100, 5, '胡海东'),"
                               + "('EE-03', '光电子学与光子学', 40, 2, '石韬')");
            
            // Insert data into selection table
            stmt.executeUpdate("INSERT INTO gauss_db.SC (S#, C#, GRADE) VALUES "
                               + "('01032010', 'CS-01', 82.0),"
                               + "('01032010', 'CS-02', 91.0),"
                               + "('01032010', 'CS-04', 83.5),"
                               + "('01032001', 'CS-01', 77.5),"
                               + "('01032001', 'CS-02', 85.0),"
                               + "('01032001', 'CS-04', 83.0),"
                               + "('01032005', 'CS-01', 62.0),"
                               + "('01032005', 'CS-02', 77.0),"
                               + "('01032005', 'CS-04', 82.0),"
                               + "('01032023', 'CS-01', 55.0),"
                               + "('01032023', 'CS-02', 81.0),"
                               + "('01032023', 'CS-04', 76.0),"
                               + "('01032112', 'CS-01', 88.0),"
                               + "('01032112', 'CS-02', 91.5),"
                               + "('01032112', 'CS-04', 86.0),"
                               + "('01032112', 'CS-05', NULL),"
                               + "('03031033', 'EE-01', 93.0),"
                               + "('03031033', 'EE-02', 89.0),"
                               + "('03031009', 'EE-01', 88.0),"
                               + "('03031009', 'EE-02', 78.5),"
                               + "('03031011', 'EE-01', 91.0),"
                               + "('03031011', 'EE-02', 86.0),"
                               + "('03031051', 'EE-01', 78.0),"
                               + "('03031051', 'EE-02', 58.0),"
                               + "('03031014', 'EE-01', 79.0),"
                               + "('03031014', 'EE-02', 71.0)");

            System.out.println("Tables created and data inserted successfully!");
            ResultSet resultSet = conn.getMetaData().getTables(null, "gauss_db", "S", null);
            if (resultSet.next()) {
                System.out.println("Table S exists in gauss_db schema.");
            } else {
                System.out.println("Table S does not exist in gauss_db schema.");
            }

        } finally {
            if (stmt != null) {
                stmt.close();
            }
        }
    }
}


``````

 通过JDBC中的executeUpdate实现创建对应表和把对应代码写入表中。

#### （2）数据类型分析

​	创建的表的各项数据类型：

``````java
 stmt.executeUpdate("CREATE TABLE gauss_db.S ("
                        + "S# CHAR(10) PRIMARY KEY,"
                        + "SNAME VARCHAR(50),"
                        + "SEX CHAR(5),"
                        + "BDATE DATE,"
                        + "HEIGHT NUMERIC(4,2),"
                        + "DORM CHAR(20)"
                        + ")");

            // Create course table in the new schema
            stmt.executeUpdate("CREATE TABLE gauss_db.C ("
                        + "C# CHAR(10) PRIMARY KEY,"
                        + "CNAME VARCHAR(100),"
                        + "PERIOD SMALLINT,"
                        + "CREDIT NUMERIC(3,1),"
                        + "TEACHER VARCHAR(50)"
                        + ")");

            // Create selection table in the new schema
            stmt.executeUpdate("CREATE TABLE gauss_db.SC ("
                        + "S# CHAR(10),"
                        + "C# CHAR(10),"
                        + "GRADE NUMERIC(4,1),"
                        + "PRIMARY KEY (S#, C#),"
                        + "FOREIGN KEY (S#) REFERENCES gauss_db.S(S#),"
                        + "FOREIGN KEY (C#) REFERENCES gauss_db.C(C#)"
                        + ")");
``````

### （2）通过Navicat查看数据类型和录入数据

#### **s469表（Student）**

![image-20240613114909993](D:\code\java\database\picture\image-20240613114909993.png)

![image-20240613124211995](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613124211995.png)

#### **c469表（Course）**

​			![image-20240619233611404](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619233611404.png)

 

![image-20240613124342445](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613124342445.png)

此处Cname定义的长度较长，是因为后续爬取的课程名较长，打到十几到几十个汉字，所以才设置为100.

#### **SC469表（选课记录表）**

​			![image-20240613115137230](D:\code\java\database\picture\image-20240613115137230.png)

![image-20240613124435680](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613124435680.png)

**SC的外键：**

![image-20240619233503865](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619233503865.png)



## 2、使用SQL语句进行查询和修改

### （1）SQL查询语句

#### （(1)） 查询电子工程系（EE）所开课程的课程编号、课程名称及学分数。

```sql
SELECT C#, CNAME, CREDIT
FROM C469
WHERE C# LIKE 'EE-%';
```
![image-20240619200451547](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619200451547.png)

#### （(2)）查询未选修课程“CS-02”的女生学号及其已选各课程编号、成绩。

```sql
SELECT S469.S#, SC469.C#, SC469.GRADE
FROM S469
JOIN SC469 ON S469.S# = SC469.S#
WHERE S469.SEX = '女' AND S469.S# NOT IN (
    SELECT S# FROM SC469 WHERE C# = 'CS-02'
);
```
![image-20240619212312882](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619212312882.png)

  **使用EXISTS语法查询**
  ```sql
      SELECT S469.S#,SC469.C#,SC469.GRADE
    FROM S469 JOIN SC469 ON S469.S#=SC469.S#
    WHERE S469.SEX = '女' AND NOT EXISTS(
        SELECT 1
        FROM SC469 SC1
        WHERE SC1.C#='CS-02' AND SC1.S#=S469.S#
    );
  ```
![image-20240619212529623](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619212529623.png)

#### （(3)）**查询 2002 年～2003 年出生学生的基本信息。**

```sql
SELECT * FROM S469
WHERE BDATE BETWEEN '2002-01-01' AND '2003-12-31';
```
 ![image-20240619200848490](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619200848490.png)

#### （(4)）**查询每位学生的学号、学生姓名及其已选修课程的学分总数。**

```sql
SELECT S469.S#, S469.SNAME, COALESCE(SUM(C469.CREDIT), 0) AS Totalcredit
FROM S469
LEFT JOIN SC469 ON S469.S# = SC469.S#
LEFT JOIN C469 ON SC469.C# = C469.C#
GROUP BY S469.S#, S469.SNAME;

```

![image-20240619200930165](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619200930165.png)

***分析：由于存在学生未选课，其获得学分为0，为此，使用COALESCE函数，返回第一个不为NULL的值，如果SUM计算为空，则返回0。***

**此外，使用左连接，保证没有任何选课记录的学生和选课成绩为空的学生也能被选中。**

#### （(5)）**查询选修课程“CS-01”的学生中成绩第二高的学生学号。**

```sql
SELECT S#
FROM SC469
WHERE C# = 'CS-01'
ORDER BY GRADE DESC
OFFSET 1 ROW FETCH NEXT 1 ROW ONLY;
```
![image-20240619201359569](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619201359569.png)

这样的查询语句有一个**潜在的问题**，即如果有多个成绩第二高的学生，理论上应该返回所有第二高学生的学号，但是这个语句只会返回一个学生的学号，为了解决这个问题，需要优化查询语句。

```sql
SELECT S#
FROM (
    SELECT S#, GRADE,
           DENSE_RANK() OVER (ORDER BY GRADE DESC) AS ranking
    FROM SC469
    WHERE C# = 'CS-01'
) AS ranked_students
WHERE ranking = 2;
```

![image-20240619201438746](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619201438746.png)

解释：

- `DENSE_RANK() OVER (ORDER BY GRADE DESC)` 将按成绩降序排列学生，并为每个学生分配一个密集的排名。
- 在外部查询中，我们选择排名为 2 的学生。这样即使有多个学生有相同的第二高成绩，也会显示所有这些学生的学号。

这个查询会返回所有选修课程 `CS-01` 并且成绩排名为第二的学生的学号。

#### （(6)）**查询平均成绩超过“王涛”同学的学生学号、姓名和平均成绩，并按学号进行降序排列。**

```sql
SELECT S469.S#, S469.SNAME, AVG(SC469.GRADE) AS AvgGrade
FROM S469
JOIN SC469 ON S469.S# = SC469.S#
GROUP BY S469.S#, S469.SNAME
HAVING AVG(SC469.GRADE) > (
    SELECT AVG(GRADE)
    FROM S469
    JOIN SC469 ON S469.S# = SC469.S#
    WHERE S469.SNAME = '王涛'
)
ORDER BY S469.S# DESC;

```
![image-20240619201550477](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619201550477.png)

#### （(7)）**查询选修了计算机专业全部课程（课程编号为“CS-××”）的学生姓名及已获得的学分总数。**

```sql
WITH C_CS AS (
SELECT C469.C#
FROM C469 
WHERE C469.C# LIKE 'CS-%'
)

SELECT S1.SNAME
FROM S469 S1 
WHERE NOT EXISTS(
SELECT 1
FROM C_CS LEFT JOIN SC469 ON C_CS.C#=SC469.C# AND  SC469.S#=S1.S#
WHERE SC469.S# IS NULL
)
GROUP BY S1.S#

```
![image-20240619201632536](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619201632536.png)

#### （(8)）**查询选修了 3 门以上课程（包括 3 门）的学生中平均成绩最高的同学学号及姓名。**

```sql
WITH AvgGradeRank AS (
    SELECT S469.S#, S469.SNAME,
           AVG(SC469.GRADE) AS AvgGrade,
           RANK() OVER (ORDER BY AVG(SC469.GRADE) DESC) AS rank
    FROM S469
    JOIN SC469 ON S469.S# = SC469.S#
    GROUP BY S469.S#, S469.SNAME
    HAVING COUNT(SC469.C#) >= 3
)
SELECT S#, SNAME
FROM AvgGradeRank
WHERE rank = 1;
```
![image-20240619203232005](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203232005.png)

**实现思路**：首先创建临时表AvgGradeRank，临时表中使用窗口函数RANK() OVER 进行排名,ORDER BY AVG(SC469.GRADE) DESC表示按平均成绩降序排名。之后再从临时表中选择rank为2的学生学号和名字，就能保证所有rank为2的学生都能被选出。

### （2）修改表

**分别在 S469和 C469表中加入记录(‘01032005’，‘刘竞’，‘男’，**
**‘2003-12-10’，1.75，‘东 14 舍 312’)及(‘CS-03’，“离散数学”，64，4，‘陈**
**建明’)。**

插入前学生S469表：  

![image-20240619203342608](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203342608.png)

插入前课程C469表：

![image-20240619203414190](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203414190.png)

**插入记录**

**插入学生记录**

```sql
INSERT INTO S469 (S#, SNAME, SEX, BDATE, HEIGHT, DORM)
VALUES ('01032005', '刘竞', '男', '2003-12-10', 1.75, '东 14 舍 312');
```



![image-20240619203629817](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203629817.png)

错误的原因是已经有了学号为01032005的学生，学号作为CK不能重复。

![image-20240619203803144](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203803144.png)

**插入课程记录**

```sql
INSERT INTO C469 (c#, cname, period, credit, teacher)  
VALUES ('CS-03', '离散数学', 64, 4, '陈建明');
```
![image-20240619203838622](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203838622.png)

![image-20240619203922132](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619203922132.png)

### （3）**将 S 表中已修学分数大于 60 的学生记录删除。**

首先确定是否有大于60学分的学生：

```SQL
SELECT SNAME 
FROM S469
JOIN SC469 ON S469.S# = SC469.S#
JOIN C469 ON SC469.C# = C469.C#
GROUP BY S469.S#
HAVING SUM(C469.CREDIT) > 60
```

![image-20240619204256313](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619204256313.png)

可以看到没有大于60分记录的学生。

```sql
DELETE FROM S469
WHERE S# IN (
    SELECT S469.S#
    FROM S469
    JOIN SC469 ON S469.S# = SC469.S#
    JOIN C469 ON SC469.C# = C469.C#
    GROUP BY S469.S#
    HAVING SUM(C469.CREDIT) > 60
);
```
删除后再查询：  
![image-20240619204112127](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619204112127.png)

### （4）**将“张明”老师负责的“信号与系统”课程的学时数调整为 64，同时增加一个学分。**

调整前：  
![image-20240619204324747](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619204324747.png)
运行调整后

```sql
UPDATE C
SET PERIOD = 64, CREDIT = CREDIT + 1
WHERE CNAME = '信号与系统' AND TEACHER = '张明';
```
![image-20240619204414122](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619204414122.png)

### （5）**建立视图：**

#### (1) **居住在“东 18 舍”的男生视图，包括学号、姓名、出生日期、身高等属性。**

```sql
CREATE VIEW MaleStudentsInEast18 AS
SELECT S#, SNAME, BDATE, HEIGHT
FROM S469
WHERE SEX = '男' AND DORM LIKE '东 18 舍%';
```
![image-20240613133757835](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613133757835.png)  

![image-20240613133806593](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613133806593.png) 可以看到视图创建成功

#### (2) **“张明”老师所开设课程情况的视图，包括课程编号、课程名称、平均成绩等属性。**

```sql
CREATE VIEW ZhangMingCourses AS
SELECT C469.C#, C469.CNAME, AVG(SC469.GRADE) AS AvgGrade
FROM C469
LEFT JOIN SC469 ON C469.C# = SC469.C#
WHERE C469.TEACHER = '张明'
GROUP BY C469.C#, C469.CNAME;
```
![image-20240613133733584](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613133733584.png)  

![image-20240613133743900](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613133743900.png)

 可以看到创建成功

#### (3) **所有选修了“人工智能”课程的学生视图，包括学号、姓名、成绩等属性。**

```sql
CREATE VIEW AIStudents AS
SELECT S469.S#, S469.SNAME, SC469.GRADE
FROM S469
JOIN SC469 ON S469.S# = SC469.S#
WHERE SC469.C# = 'CS-04';
```

![image-20240613133842218](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613133842218.png)

![image-20240613133850865](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613133850865.png)

创建成功。

## 3、生成数据和爬取数据

#### 3.1  S补充至约1000行，C补充约100行，SC补充约2000行，补充过程中删除数据。

##### 3.1.1 补充S数据

###### 3.1.1.1 S数据爬取

​	使用python爬虫爬取数据，由于学生的学号，宿舍等信息不易爬取，学生信息中只选择爬取姓名，其他数据根据要求随机生成。爬取[西安交通大学电气工程学院复试名单](https://ee.xjtu.edu.cn/info/1383/12513.htm)，网页内容如下：

![image-20240613134359888](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613134359888.png)

​	爬取代码

   ```python
import openpyxl
from lxml import etree
# 创建一个新的excel工作簿
workbook=openpyxl.Workbook()
# 获取默认的工作表
sheet=workbook.active
sheet['B1']='SNAME'
url="https://ee.xjtu.edu.cn/info/1383/12513.htm"
response=requests.get(url)
# 将html页面内容转换为xml文档对象
html=etree.HTML(response.content)
datalist=html.xpath('//tr')
for item in datalist:
    name=item.xpath('./td[2]/p/text()')
    if len(name)>0:
        sheet.append([' ',f'{name[0]}'])
workbook.save('D:\code\python\icourese\Sname.xlsx')
   ```



爬取后的表格：

![image-20240613134912176](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613134912176.png)

###### 3.1.1.2 完善表格随机生成其他数据

给学生分配学号，出生日期，身高，性别，宿舍号，分配时有以下几点需要注意：

​	1、学号作为CK不能重复。

​	2、女生身高应该平均低于男生身高，符合常理。身高整体应符合正态分布。

​	3、男女生不能分配到同一个宿舍，这里直接设置男女生分配到不同的宿舍楼,考虑到已有的学生信息，把1-5舍，11-15舍分配给女生，6-10舍，16-20舍分配给男生。

​	4、学生出生日期区别不能太大，此处设置为2002-01-01到2005-12-31。

```python
import openpyxl
import random
from datetime import datetime, timedelta
import pandas as pd

def generate_student_id(existing_ids):
    exclude_ids = ['01032010', '01032023', '01032001', '01032005', 
                   '01032112', '03031011', '03031014', '03031051', 
                   '03031009', '03031033', '03031056']
    
    while True:
        student_id = ''.join(random.choices('0123456789', k=8))
        if student_id not in existing_ids and student_id not in exclude_ids:
            return student_id


def generate_gender():
    return random.choice(['男', '女'])

def generate_birthdate():
    start_date = datetime.strptime('2002-01-01', '%Y-%m-%d')
    end_date = datetime.strptime('2005-12-31', '%Y-%m-%d')
    random_date = start_date + timedelta(days=random.randint(0, (end_date - start_date).days))
    return random_date.strftime('%Y-%m-%d')

def generate_height(gender):
    if gender == '男':
        return round(random.uniform(1.6, 1.9), 2)
    elif gender == '女':
        return round(random.uniform(1.55, 1.8), 2)
    else:
        return None

def generate_dorm(assigned_dorms, gender):
    while True:
        building = random.choice(['东', '西'])
        
        if gender == '女':
            # 女生只能分配到楼层 1-5 和 11-15
            floor = random.choice([1, 2, 3, 4, 5, 11, 12, 13, 14, 15])
        else:
            # 男生可以分配到除了 1-5 和 11-15 外的其他楼层
            floor = random.randint(6, 10)  # 楼层范围从6到10
        
        fls = str(random.randint(1, 9))  # 确保是两位数，如09
        room = str(random.randint(1, 40)).zfill(2)  # 房间号，确保是两位数，如05

        room_number = f'{building} {floor} 舍 {fls}{room}'

        # 获取已分配的宿舍情况
        male_dorms = [dorm['dorm'] for dorm in assigned_dorms if dorm['gender'] == '男']
        female_dorms = [dorm['dorm'] for dorm in assigned_dorms if dorm['gender'] == '女']

        # 如果只有男性宿舍或只有女性宿舍，则后续只能分配相应性别
        if room_number in female_dorms and gender == '女':
            continue
        elif room_number in male_dorms and gender == '男':
            continue

        # 如果没有冲突的宿舍分配，则返回宿舍号和性别
        break

    return room_number, gender


def main():
    # 打开Excel文件
    wb = openpyxl.load_workbook(r'D:\code\python\icourese\origin_table\Sname.xlsx')
    ws = wb.active

    existing_ids = set()
    assigned_dorms = []

    # 生成学号、性别、出生日期、身高和宿舍号并写入Excel文件
    for idx, row in enumerate(ws.iter_rows(min_row=1, max_col=1, values_only=True), start=1):
        student_name = row[0]
        student_id = generate_student_id(existing_ids)
        gender = generate_gender()
        birthdate = generate_birthdate()
        height = generate_height(gender)
        dorm, dorm_gender = generate_dorm(assigned_dorms, gender)
        existing_ids.add(student_id)
        assigned_dorms.append({'dorm': dorm, 'gender': dorm_gender})
        
        # 写入Excel文件，第一列为学号，第二列为性别，依次类推
        ws.cell(row=idx, column=1, value=student_id)
        ws.cell(row=idx, column=2, value=student_name)  # 调换了第一列和第二列的位置
        ws.cell(row=idx, column=3, value=gender)
        ws.cell(row=idx, column=4, value=birthdate)
        ws.cell(row=idx, column=5, value=height)
        ws.cell(row=idx, column=6, value=dorm)

    wb.save(r'D:\\code\\python\\icourese\\processed_table\\New_Processed_Sname_table.xlsx')


if __name__ == "__main__":
    main()


```

补充后的表格：

![image-20240613143720554](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613143720554.png)

###### 3.1.2 使用JDBC写入生成数据到数据库

```java
package com.sxt;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class Insert_new_Student {
    public static void main(String[] args) {
        System.out.println("Hello, World!");

        // Database connection parameters
        String url = "jdbc:postgresql://192.168.3.28:5432/mydb";
        String user = "java";
        String password = "xyx2003.";

        Connection conn = null;
        try {
            // Load the PostgreSQL driver (optional step in modern JDBC)
            Class.forName("org.postgresql.Driver");

            // Get a connection to the database
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("Connection established successfully!");

            // Read Excel file and insert or update data into the database
            String excelFilePath = "D:\\code\\python\\icourese\\processed_table\\New_Processed_Sname_table.xlsx";
            readAndInsertOrUpdateData(conn, excelFilePath);

        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("IOException: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close the connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("Failed to close the connection: " + e.getMessage());
                }
            }
        }
    }

    public static void readAndInsertOrUpdateData(Connection conn, String excelFilePath) throws IOException, SQLException {
        try (FileInputStream fis = new FileInputStream(excelFilePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0);

            // SQL语句，注意不包含ON CONFLICT子句
            String sql = "INSERT INTO gauss_db.s (S#, SNAME, SEX, BDATE, HEIGHT, DORM) "
                       + "VALUES (?, ?, ?, ?, ?, ?)";

            try (PreparedStatement pstmtInsert = conn.prepareStatement(sql)) {
                for (Row row : sheet) {
                    if (row.getRowNum() == 0) {
                        // Skip header row
                        continue;
                    }

                    String sNumber = getCellValue(row.getCell(0));
                    String sName = getCellValue(row.getCell(1));
                    String sex = getCellValue(row.getCell(2));
                    String bDate = getCellValue(row.getCell(3));
                    String height = getCellValue(row.getCell(4));
                    String dorm = getCellValue(row.getCell(5));

                    System.out.println("S#: " + sNumber + ", SName: " + sName + ", Sex: " + sex + ", BDate: " + bDate + ", Height: " + height + ", Dorm: " + dorm);

                    // 设置参数
                    pstmtInsert.setString(1, sNumber);
                    pstmtInsert.setString(2, sName);
                    pstmtInsert.setString(3, sex);
                    pstmtInsert.setString(4, bDate);
                    pstmtInsert.setString(5, height);
                    pstmtInsert.setString(6, dorm);

                    try {
                        pstmtInsert.executeUpdate();
                    } catch (SQLException ex) {
                        // 如果发生主键冲突，执行更新操作
                        if (ex.getSQLState().equals("23505")) { // 23505 是主键冲突的SQL状态码
                            System.out.println("Duplicate key found, updating record...");

                            String updateSql = "UPDATE gauss_db.s "
                                             + "SET SNAME = ?, "
                                             + "SEX = ?, "
                                             + "BDATE = ?, "
                                             + "HEIGHT = ?, "
                                             + "DORM = ? "
                                             + "WHERE S# = ?";

                            try (PreparedStatement pstmtUpdate = conn.prepareStatement(updateSql)) {
                                pstmtUpdate.setString(1, sName);
                                pstmtUpdate.setString(2, sex);
                                pstmtUpdate.setString(3, bDate);
                                pstmtUpdate.setString(4, height);
                                pstmtUpdate.setString(5, dorm);
                                pstmtUpdate.setString(6, sNumber);

                                pstmtUpdate.executeUpdate();
                            }
                        } else {
                            throw ex; // 如果不是主键冲突，抛出异常
                        }
                    }
                }
            }
        }
    }

    private static String getCellValue(Cell cell) {
        if (cell == null) {
            return "";
        }
        switch (cell.getCellTypeEnum()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue().toString();
                } else {
                    return Double.toString(cell.getNumericCellValue());
                }
            case BOOLEAN:
                return Boolean.toString(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            case BLANK:
                return "";
            default:
                return "";
        }
    }
}

```

写入后：![image-20240613150745030](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613150745030.png)

##### 3.1.2 补充C数据

###### 	3.1.2.1 C数据爬取

​	只爬取课程名，其他信息通过补全生成。使用python爬虫爬取数据，爬取网站为[中国大学mooc](f'http://www.imooc.com/course/list/)一个子页面，页面如下：![image-20240613151129543](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613151129543.png)

代码：

```python
from bs4 import BeautifulSoup
import requests
import os
from openpyxl import Workbook, load_workbook

# 文件路径
file_path = 'D:\\code\\python\\icourese\\Cname.xlsx'

# 创建或加载Excel文件
if os.path.exists(file_path):
    wb = load_workbook(file_path)
    ws = wb.active
else:
    wb = Workbook()
    ws = wb.active
    # 写入表头（如果需要）
    ws.append(['Course Name'])

# 请求头
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36',
    'cookie': 'imooc_uuid=86ab3b90-3f49-41aa-ab5e-52d53e209d85; imooc_isnew=1; imooc_isnew_ct=1717230404; tgw_l7_route=126bb7f6409ec5ff7744080c81a70225; sajssdk_2015_cross_new_user=1; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2218fd2e889f68f0-02cdb6893c548f8-26001c51-2359296-18fd2e889f75a8%22%2C%22first_id%22%3A%22%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%2C%22%24latest_referrer%22%3A%22%22%7D%2C%22identities%22%3A%22eyIkaWRlbnRpdHlfY29va2llX2lkIjoiMThmZDJlODg5ZjY4ZjAtMDJjZGI2ODkzYzU0OGY4LTI2MDAxYzUxLTIzNTkyOTYtMThmZDJlODg5Zjc1YTgifQ%3D%3D%22%2C%22history_login_id%22%3A%7B%22name%22%3A%22%22%2C%22value%22%3A%22%22%7D%2C%22%24device_id%22%3A%2218fd2e889f68f0-02cdb6893c548f8-26001c51-2359296-18fd2e889f75a8%22%7D; Hm_lvt_f0cfcccd7b1393990c78efdeebff3968=1717230406; Hm_lpvt_f0cfcccd7b1393990c78efdeebff3968=1717230412; cvde=665adb44bd037-4'
}

# 循环访问第2页到第10页的内容
for page in range(1, 11):
    # 构造URL
    url = f'http://www.imooc.com/course/list/?page={page}'

    # 发送HTTP请求获取网页内容
    response = requests.get(url, headers=headers)

    # 创建BeautifulSoup对象
    soup = BeautifulSoup(response.text, 'html.parser')

    # 提取符合条件的<a>标签
    a_tags = soup.find_all('a', class_="item free")

    # 提取并写入data-title属性的值
    for tag in a_tags:
        data_title = tag.get('data-title')
        if data_title:
            print(data_title)
            ws.append([data_title])

# 保存Excel文件
wb.save(file_path)
print('数据爬取完成！')

```

爬取到的课程名示例：

![image-20240613151240370](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613151240370.png)

###### 3.1.2.2 C数据补充  

​	使用python语言补充表格。

​	补充时的设计：

​	（1）学时不能太少也不能太多，统一设置为24-80区间，且能被4整除（考虑到一节课2h），这样设置的学时比较合理。

​	（2）学分credit应该和学时成正相关，即学时越多学分应该相应更高。使用学时除以20，当小数点后小于0.5时向下取整，大于等于0.5时保留到0.5。

```python
import pandas as pd
import random
import openpyxl
from faker import Faker
from math import floor

# 创建一个新的Excel文件
file_path = r'D:\code\python\icourese\processed_table\Processed_Course.xlsx'
wb = openpyxl.Workbook()
ws = wb.active
ws.title = 'Sheet1'

# 生成AA-BB
AA_values = ["CS", "EE", "ME", "CE", "BE", "AE", "EC", "FN", "MA", "MT", "PH", "CH", "BI", "AR", "DE", "PS", "ST", "GE", "HI", "LS"]
excluded_codes = ["CS-01", "CS-02", "CS-04", "CS-05", "EE-02", "EE-03", "CS-03", "EE-01"]
generated_codes = set(excluded_codes)

while len(generated_codes) < 100 + len(excluded_codes):
    AA = random.choice(AA_values)
    BB = f"{random.randint(1, 99):02}"
    code = f"{AA}-{BB}"
    if code not in generated_codes:
        generated_codes.add(code)

# 去掉排除的代码，只保留生成的100个代码
generated_codes -= set(excluded_codes)
generated_codes = list(generated_codes)[:100]

# 写入第一列
for i, code in enumerate(generated_codes, start=2):
    ws.cell(row=i, column=1, value=code)

# 读取现有Excel文件中的数据并写入新文件的第二列
origin_file_path = r'D:\code\python\icourese\origin_table\Cname.xlsx'
origin_data = pd.read_excel(origin_file_path)
second_column_data = origin_data.iloc[1:101, 0].tolist()  # 读取第2行到第101行的数据

for i, data in enumerate(second_column_data, start=2):
    ws.cell(row=i, column=2, value=data)

# 随机生成指定范围内的数字，并写入第三列和第四列
for i in range(2, 102):
    num = random.choice(range(24, 101, 4))
    decimal_part = num % 20 / 20.0  # 计算小数部分
    if decimal_part >= 0.5:
        adjusted_num = floor(num / 20.0) + 0.5
    else:
        adjusted_num = floor(num / 20.0)
    ws.cell(row=i, column=3, value=num)
    ws.cell(row=i, column=4, value=adjusted_num)

# 随机生成中文名字并写入第五列
faker = Faker('zh_CN')
for i in range(2, 102):
    name = faker.name()
    ws.cell(row=i, column=5, value=name)

# 保存Excel文件
wb.save(file_path)
```

补充后的S表：

![image-20240613152605386](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613152605386.png)

###### 3.1.2.3 使用JDBC写入生成数据到数据库

```java
package com.sxt;
import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class Insert_Course {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
        
        // Database connection parameters
        String url = "jdbc:postgresql://192.168.3.28:5432/mydb";
        String user = "java";
        String password = "xyx2003.";
        
        Connection conn = null;
        try {
            // Load the PostgreSQL driver (optional step in modern JDBC)
            Class.forName("org.postgresql.Driver");
            
            // Get a connection to the database
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("Connection established successfully!");
            
            // Read Excel file and insert data into the database
            String excelFilePath = "D:\\code\\python\\icourese\\processed_table\\Processed_Course.xlsx";
            insertDataFromExcel(conn, excelFilePath);
            
        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("IOException: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close the connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("Failed to close the connection: " + e.getMessage());
                }
            }
        }
    }
    
    // Method to read data from Excel and insert it into the database
    public static void insertDataFromExcel(Connection conn, String excelFilePath) throws IOException, SQLException {
        FileInputStream fis = new FileInputStream(excelFilePath);
        Workbook workbook = new XSSFWorkbook(fis);
        Sheet sheet = workbook.getSheetAt(0);
        
        String sql = "INSERT INTO gauss_db.c (c#, cname, period, credit, teacher) VALUES (?, ?, ?, ?, ?)";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        
        for (Row row : sheet) {
            if (row.getRowNum() == 0) {
                // Skip header row
                continue;
            }
            
            String cNum = getCellValue(row.getCell(0));
            String cName = getCellValue(row.getCell(1));
            int period = (int) row.getCell(2).getNumericCellValue();  // Ensuring period is an integer
            int credit = (int) row.getCell(3).getNumericCellValue();  // Ensuring credit is an integer
            String teacher = getCellValue(row.getCell(4));
            
            pstmt.setString(1, cNum);
            pstmt.setString(2, cName);
            pstmt.setInt(3, period);
            pstmt.setInt(4, credit);
            pstmt.setString(5, teacher);
            
            pstmt.addBatch();
        }
        
        pstmt.executeBatch();
        workbook.close();
        fis.close();
    }
    
    // Helper method to get cell value as string
    private static String getCellValue(Cell cell) {
        if (cell == null) {
            return "";
        }
        switch (cell.getCellTypeEnum()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                return String.valueOf((int) cell.getNumericCellValue());  // Assuming numeric values can be cast to int
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            default:
                return "";
        }
    }
}
```

##### 3.1.3 补充SC数据并随机删除200条grade低于60分的数据。

```java
package com.sxt;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class CourseSelectionManager {

    public static void main(String[] args) {
        System.out.println("Hello, World!");

        // 数据库连接参数
        String url = "jdbc:postgresql://192.168.3.28:5432/mydb";
        String user = "java";
        String password = "xyx2003.";

        Connection conn = null;
        try {
            // 加载PostgreSQL驱动（在现代JDBC中是可选的）
            Class.forName("org.postgresql.Driver");

            // 获取数据库连接
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("连接成功建立！");

            // 创建一个ExecutorService来管理线程
            ExecutorService executor = Executors.newFixedThreadPool(10);

            // 第一步：在一个单独的线程中为学生分配课程
            executor.submit(() -> {
                try {
                    assignCoursesToStudents(conn);
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            });

            // 第二步：在一个单独的线程中删除随机低分条目
            executor.submit(() -> {
                try {
                    deleteRandomLowGrades(conn);
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            });

            // 关闭executor并等待任务完成
            executor.shutdown();
            executor.awaitTermination(1, TimeUnit.HOURS);

        } catch (SQLException e) {
            System.out.println("SQL异常: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("找不到PostgreSQL JDBC驱动: " + e.getMessage());
            e.printStackTrace();
        } catch (InterruptedException e) {
            System.out.println("线程中断: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // 关闭连接
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("关闭连接失败: " + e.getMessage());
                }
            }
        }
    }

    private static void assignCoursesToStudents(Connection conn) throws SQLException {
        Statement stmt = null;
        ResultSet rs = null;
        List<String> studentIds = new ArrayList<>();
        List<String> courseIds = new ArrayList<>();
        Random random = new Random();

        try {
            stmt = conn.createStatement();
            // 获取所有学生ID
            rs = stmt.executeQuery("SELECT S# FROM gauss_db.S");
            while (rs.next()) {
                studentIds.add(rs.getString("S#"));
            }
            rs.close();

            // 获取所有课程ID
            rs = stmt.executeQuery("SELECT C# FROM gauss_db.C");
            while (rs.next()) {
                courseIds.add(rs.getString("C#"));
            }
            rs.close();

            // 创建一个线程池
            ExecutorService executor = Executors.newFixedThreadPool(10);

            // 为每个学生分配20门课程
            for (String studentId : studentIds) {
                executor.submit(() -> {
                    Set<String> assignedCourses = new HashSet<>();
                    int coursesAssigned = 0;
                    while (coursesAssigned < 20) {
                        String courseId = courseIds.get(random.nextInt(courseIds.size()));
                        if (!assignedCourses.contains(courseId)) {
                            double grade = generateGrade(random);
                            try (Statement localStmt = conn.createStatement()) {
                                localStmt.executeUpdate("INSERT INTO gauss_db.SC (S#, C#, GRADE) VALUES "
                                        + "('" + studentId + "', '" + courseId + "', " + grade + ")");
                                assignedCourses.add(courseId);
                                coursesAssigned++;
                            } catch (SQLException e) {
                                if (e.getSQLState().equals("23505")) {
                                    // 主键重复，跳过此课程并尝试另一个
                                    continue;
                                } else {
                                    throw new RuntimeException(e);
                                }
                            }
                        }
                    }
                });
            }

            executor.shutdown();
            executor.awaitTermination(1, TimeUnit.HOURS);
            System.out.println("课程成功分配给学生！");

        } catch (InterruptedException e) {
            System.out.println("线程中断: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (rs != null) {
                rs.close();
            }
        }
    }

    private static double generateGrade(Random random) {
        // 生成平均分为80的成绩
        return 70 + random.nextGaussian() * 10;
    }

    private static void deleteRandomLowGrades(Connection conn) throws SQLException {
        Statement stmt = null;
        ResultSet rs = null;
        List<String> lowGradeEntries = new ArrayList<>();
        Random random = new Random();

        try {
            stmt = conn.createStatement();
            // 获取所有成绩低于60的条目
            rs = stmt.executeQuery("SELECT S#, C# FROM gauss_db.SC WHERE GRADE < 60");
            while (rs.next()) {
                lowGradeEntries.add(rs.getString("S#") + "," + rs.getString("C#"));
            }
            rs.close();

            // 随机删除200个低分条目
            ExecutorService executor = Executors.newFixedThreadPool(10);

            for (int i = 0; i < 200 && !lowGradeEntries.isEmpty(); i++) {
                executor.submit(() -> {
                    int index = random.nextInt(lowGradeEntries.size());
                    String[] ids = lowGradeEntries.remove(index).split(",");
                    try (Statement localStmt = conn.createStatement()) {
                        localStmt.executeUpdate("DELETE FROM gauss_db.SC WHERE S# = '" + ids[0] + "' AND C# = '" + ids[1] + "'");
                    } catch (SQLException e) {
                        throw new RuntimeException(e);
                    }
                });
            }

            executor.shutdown();
            executor.awaitTermination(1, TimeUnit.HOURS);
            System.out.println("200个低分条目成功删除！");

        } catch (InterruptedException e) {
            System.out.println("线程中断: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (rs != null) {
                rs.close();
            }
        }
    }
}


```

**关键点说明：**

关键代码：

```java
            // 创建一个ExecutorService来管理线程
            ExecutorService executor = Executors.newFixedThreadPool(10);

            // 第一步：在一个单独的线程中为学生分配课程
            executor.submit(() -> {
                try {
                    assignCoursesToStudents(conn);
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            });

            // 第二步：在一个单独的线程中删除随机低分条目
            executor.submit(() -> {
                try {
                    deleteRandomLowGrades(conn);
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            });

            // 关闭executor并等待任务完成
            executor.shutdown();
            executor.awaitTermination(1, TimeUnit.HOURS);
```



1. **并行执行**：使用`ExecutorService`将`assignCoursesToStudents`和`deleteRandomLowGrades`两个任务并行提交，确保它们可以同时运行。
2. **线程安全**：每个任务使用自己的`Statement`对象来避免并发问题。
3. **关闭和等待终止**：在提交任务后，调用`shutdown()`来停止接受新任务，并调用`awaitTermination()`来等待所有任务完成，确保所有操作在给定时间内（此处为1小时）完成。

生成后各表行数：

![image-20240613170545716](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613170545716.png)![image-20240613170603463](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613170603463.png)![image-20240613170651569](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240613170651569.png)

#### 3.2 ．在 S中补充至 5000 行，在 C表中补充数据至约 1000行，在 SC表中补充数据至约 200000 行。

由于数据太多不方便爬取，故此处S补充数据和C补充数据均通过python代码随机生成。

##### 3.2.1 S数据生成：

```python
import openpyxl
import random
from datetime import datetime, timedelta
from faker import Faker

def generate_student_id(existing_ids):
    exclude_ids = ['01032010', '01032023', '01032001', '01032005', 
                   '01032112', '03031011', '03031014', '03031051', 
                   '03031009', '03031033', '03031056']
    
    while True:
        student_id = ''.join(random.choices('0123456789', k=8))
        if student_id not in existing_ids and student_id not in exclude_ids:
            return student_id

def generate_gender():
    return random.choice(['男', '女'])

def generate_birthdate():
    start_date = datetime.strptime('2002-01-01', '%Y-%m-%d')
    end_date = datetime.strptime('2005-12-31', '%Y-%m-%d')
    random_date = start_date + timedelta(days=random.randint(0, (end_date - start_date).days))
    return random_date.strftime('%Y-%m-%d')

def generate_height(gender):
    if gender == '男':
        return round(random.uniform(1.6, 1.9), 2)
    elif gender == '女':
        return round(random.uniform(1.55, 1.8), 2)
    else:
        return None

def generate_dorm(assigned_dorms, gender):
    while True:
        building = random.choice(['东', '西'])
        
        if gender == '女':
            # 女生只能分配到楼层 1-5 和 11-15
            floor = random.choice([1, 2, 3, 4, 5, 11, 12, 13, 14, 15])
        else:
            # 男生可以分配到除了 1-5 和 11-15 外的其他楼层
            floor = random.randint(6, 10)  # 楼层范围从6到10
        
        fls = str(random.randint(1, 9))  # 确保是两位数，如09
        room = str(random.randint(1, 40)).zfill(2)  # 房间号，确保是两位数，如05

        room_number = f'{building} {floor} 舍 {fls}{room}'

        # 获取已分配的宿舍情况
        male_dorms = [dorm['dorm'] for dorm in assigned_dorms if dorm['gender'] == '男']
        female_dorms = [dorm['dorm'] for dorm in assigned_dorms if dorm['gender'] == '女']

        # 如果只有男性宿舍或只有女性宿舍，则后续只能分配相应性别
        if room_number in female_dorms and gender == '女':
            continue
        elif room_number in male_dorms and gender == '男':
            continue

        # 如果没有冲突的宿舍分配，则返回宿舍号和性别
        break

    return room_number, gender

def main():
    # 打开Excel文件
    wb = openpyxl.load_workbook(r'D:\code\python\icourese\processed_table\New_Processed_Sname_table.xlsx')
    ws = wb.active

    existing_ids = set()
    assigned_dorms = []

    # 读取已有的学号并添加到exclude_ids中
    for row in ws.iter_rows(min_row=2, max_col=1, values_only=True):
        existing_ids.add(row[0])

    # 使用faker生成中文名
    faker = Faker(locale='zh_CN')

    # 生成4000个条目
    for idx in range(1, 4001):
        student_name = faker.name()
        student_id = generate_student_id(existing_ids)
        gender = generate_gender()
        birthdate = generate_birthdate()
        height = generate_height(gender)
        dorm, dorm_gender = generate_dorm(assigned_dorms, gender)
        existing_ids.add(student_id)
        assigned_dorms.append({'dorm': dorm, 'gender': dorm_gender})
        
        # 写入Excel文件，第一列为学号，第二列为姓名，依次类推
        ws.cell(row=len(existing_ids), column=1, value=student_id)
        ws.cell(row=len(existing_ids), column=2, value=student_name)
        ws.cell(row=len(existing_ids), column=3, value=gender)
        ws.cell(row=len(existing_ids), column=4, value=birthdate)
        ws.cell(row=len(existing_ids), column=5, value=height)
        ws.cell(row=len(existing_ids), column=6, value=dorm)

    # 保存到新的Excel文件
    wb.save(r'D:\code\python\icourese\last_work\Sname.xlsx')

if __name__ == "__main__":
    main()

```



##### 3.2.2 C数据生成

已经存在100条的数据，之前爬取到的数据有接近500条，直接按之前爬取到的数据的名称后缀上加上'-I'和'II'，使课程名加倍。

```python
import os
import openpyxl

# 定义读取Excel文件路径和生成的Excel文件路径
input_file = r'D:\code\python\icourese\origin_table\Cname.xlsx'
output_folder = r'D:\code\python\icourese\temp'
output_file = os.path.join(output_folder, 'Course.xlsx')

# 打开并读取Excel文件
wb = openpyxl.load_workbook(input_file)
sheet = wb.active

# 获取第一列的课程名数据
courses = [sheet.cell(row=i, column=1).value for i in range(1, sheet.max_row + 1)]

# 创建一个新的Excel文件
wb_output = openpyxl.Workbook()
sheet_output = wb_output.active
sheet_output.title = 'Courses'

# 写入Excel文件
row_index = 1
for course in courses:
    sheet_output.cell(row=row_index, column=1, value=f'{course}-I')
    sheet_output.cell(row=row_index + 1, column=1, value=f'{course}-II')
    row_index += 2  # 每个课程名的两个变体占据两行

# 确保目标文件夹存在，如果不存在则创建
if not os.path.exists(output_folder):
    os.makedirs(output_folder)

# 保存Excel文件
wb_output.save(output_file)
print(f"课程名变体已成功保存到 {output_file}")

```

完善课程信息：

```python
import random
import openpyxl
from math import floor
from faker import Faker

# 创建一个新的Excel文件
file_path = r'D:\code\python\icourese\last_work\Cname.xlsx'
wb = openpyxl.Workbook()
ws = wb.active
ws.title = 'Sheet1'

# 生成AA-BB
AA_values = ["CS", "EE", "ME", "CE", "BE", "AE", "EC", "FN", "MA", "MT", "PH", "CH", "BI", "AR", "DE", "PS", "ST", "GE", "HI", "LS",
             "MU", "LT", "ET", "IT", "SE", "AI", "CI", "EN", "LE", "FE", "RE", "UE", "IE", "OE", "YE", "WE", "NE", "XE", "TE"]
excluded_codes = ["CS-01", "CS-02", "CS-04", "CS-05", "EE-02", "EE-03", "CS-03", "EE-01"]

# 读取现有Excel文件中的课程代码并添加到排除列表中
existing_codes_wb = openpyxl.load_workbook(r'D:\code\python\icourese\processed_table\Processed_Course.xlsx')
existing_codes_ws = existing_codes_wb.active
existing_codes = [existing_codes_ws.cell(row=i, column=1).value for i in range(2, existing_codes_ws.max_row + 1)]
excluded_codes += existing_codes

# 读取课程名的Excel文件
course_file = r'D:\code\python\icourese\temp\Course.xlsx'
course_wb = openpyxl.load_workbook(course_file)
course_ws = course_wb.active

# 获取课程名列的数据
generated_courses = [course_ws.cell(row=i, column=1).value for i in range(1, course_ws.max_row + 1)]

# 创建 Faker 实例
faker = Faker('zh_CN')

# 写入第一列（课程代码）
generated_codes = set()
while len(generated_codes) < 900:
    AA = random.choice(AA_values)
    BB = f"{random.randint(1, 99):02}"
    code = f"{AA}-{BB}"
    if code not in generated_codes and code not in excluded_codes:
        generated_codes.add(code)

# 写入第二列（课程名）
for i, code in enumerate(generated_codes, start=2):
    ws.cell(row=i, column=1, value=code)
    ws.cell(row=i, column=2, value=generated_courses[i - 2])

# 随机生成指定范围内的数字，并写入第三列和第四列
for i in range(2, 902):
    num = random.choice(range(24, 101, 4))
    decimal_part = num % 20 / 20.0  # 计算小数部分
    if decimal_part >= 0.5:
        adjusted_num = floor(num / 20.0) + 0.5
    else:
        adjusted_num = floor(num / 20.0)
    ws.cell(row=i, column=3, value=num)
    ws.cell(row=i, column=4, value=adjusted_num)

# 随机生成中文名字并写入第五列
for i in range(2, 902):
    name = faker.name()
    ws.cell(row=i, column=5, value=name)

# 保存Excel文件
wb.save(file_path)
print(f"文件已保存到 {file_path}")
```

##### 3.2.3 S和C数据写入

S数据写入

```java
package com.sxt;

import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class Insert_Student2 {
    public static void main(String[] args) {
        System.out.println("Hello, World!");

        // Database connection parameters
        String url = "jdbc:postgresql://192.168.3.28:5432/mydb";
        String user = "java";
        String password = "xyx2003.";

        Connection conn = null;
        try {
            // Load the PostgreSQL driver (optional step in modern JDBC)
            Class.forName("org.postgresql.Driver");

            // Get a connection to the database
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("Connection established successfully!");

            // Read Excel file and insert or update data into the database
            String excelFilePath = "D:\\code\\python\\icourese\\last_work\\Sname.xlsx";
            readAndInsertOrUpdateData(conn, excelFilePath);

        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println("IOException: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close the connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("Failed to close the connection: " + e.getMessage());
                }
            }
        }
    }

    public static void readAndInsertOrUpdateData(Connection conn, String excelFilePath) throws IOException, SQLException {
        try (FileInputStream fis = new FileInputStream(excelFilePath);
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0);

            // SQL语句，注意不包含ON CONFLICT子句
            String sql = "INSERT INTO gauss_db.s (S#, SNAME, SEX, BDATE, HEIGHT, DORM) "
                       + "VALUES (?, ?, ?, ?, ?, ?)";

            try (PreparedStatement pstmtInsert = conn.prepareStatement(sql)) {
                for (Row row : sheet) {
                    if (row.getRowNum() == 0) {
                        // Skip header row
                        continue;
                    }

                    String sNumber = getCellValue(row.getCell(0));
                    String sName = getCellValue(row.getCell(1));
                    String sex = getCellValue(row.getCell(2));
                    String bDate = getCellValue(row.getCell(3));
                    String height = getCellValue(row.getCell(4));
                    String dorm = getCellValue(row.getCell(5));

                    System.out.println("S#: " + sNumber + ", SName: " + sName + ", Sex: " + sex + ", BDate: " + bDate + ", Height: " + height + ", Dorm: " + dorm);

                    // 设置参数
                    pstmtInsert.setString(1, sNumber);
                    pstmtInsert.setString(2, sName);
                    pstmtInsert.setString(3, sex);
                    pstmtInsert.setString(4, bDate);
                    pstmtInsert.setString(5, height);
                    pstmtInsert.setString(6, dorm);

                    try {
                        pstmtInsert.executeUpdate();
                        System.err.println("succeed insert");
                    } catch (SQLException ex) {
                        // 如果发生主键冲突，执行更新操作
                        if (ex.getSQLState().equals("23505")) { // 23505 是主键冲突的SQL状态码
                            System.out.println("Duplicate key found, updating record...");

                            String updateSql = "UPDATE gauss_db.s "
                                             + "SET SNAME = ?, "
                                             + "SEX = ?, "
                                             + "BDATE = ?, "
                                             + "HEIGHT = ?, "
                                             + "DORM = ? "
                                             + "WHERE S# = ?";

                            try (PreparedStatement pstmtUpdate = conn.prepareStatement(updateSql)) {
                                pstmtUpdate.setString(1, sName);
                                pstmtUpdate.setString(2, sex);
                                pstmtUpdate.setString(3, bDate);
                                pstmtUpdate.setString(4, height);
                                pstmtUpdate.setString(5, dorm);
                                pstmtUpdate.setString(6, sNumber);

                                pstmtUpdate.executeUpdate();
                            }
                        } else {
                            throw ex; // 如果不是主键冲突，抛出异常
                        }
                    }
                }
            }
        }
    }

    private static String getCellValue(Cell cell) {
        if (cell == null) {
            return "";
        }
        switch (cell.getCellTypeEnum()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getDateCellValue().toString();
                } else {
                    return Double.toString(cell.getNumericCellValue());
                }
            case BOOLEAN:
                return Boolean.toString(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            case BLANK:
                return "";
            default:
                return "";
        }
    }
}

```

C数据写入：

```java
package com.sxt;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

public class Courseselection2 {

    public static void main(String[] args) {
        System.out.println("Hello, World!");

        // Database connection parameters
        String url = "jdbc:postgresql://192.168.3.28:5432/mydb";
        String user = "java";
        String password = "xyx2003.";

        Connection conn = null;
        try {
            // Load the PostgreSQL driver (optional step in modern JDBC)
            Class.forName("org.postgresql.Driver");

            // Get a connection to the database
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("Connection established successfully!");

            // Assign courses to students
            assignCoursesToStudents(conn);

        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close the connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("Failed to close the connection: " + e.getMessage());
                }
            }
        }
    }

    private static void assignCoursesToStudents(Connection conn) throws SQLException {
        Statement stmt = null;
        ResultSet rs = null;
        List<String> studentIds = new ArrayList<>();
        List<String> courseIds = new ArrayList<>();
        Random random = new Random();

        try {
            stmt = conn.createStatement();
            // Get all student IDs
            rs = stmt.executeQuery("SELECT S# FROM gauss_db.S");
            while (rs.next()) {
                studentIds.add(rs.getString("S#"));
            }
            rs.close();

            // Get all course IDs
            rs = stmt.executeQuery("SELECT C# FROM gauss_db.C");
            while (rs.next()) {
                courseIds.add(rs.getString("C#"));
            }
            rs.close();

            // For each student, assign courses
            for (String studentId : studentIds) {
                // Check if the student already has course records
                rs = stmt.executeQuery("SELECT COUNT(*) AS course_count FROM gauss_db.SC WHERE S# = '" + studentId + "'");
                rs.next();
                int existingCourses = rs.getInt("course_count");
                rs.close();

                int coursesToAssign = existingCourses > 0 ? 20 : 40;
                System.err.println("course="+ coursesToAssign);
                Set<String> assignedCourses = new HashSet<>();
                int coursesAssigned = 0;

                while (coursesAssigned < coursesToAssign) {
                    String courseId = courseIds.get(random.nextInt(courseIds.size()));
                    System.out.println("courseId is "+courseId);
                    System.out.println(coursesAssigned+"//"+coursesToAssign);
                    // Check if the course already has 300 students
                    rs = stmt.executeQuery("SELECT COUNT(*) AS student_count FROM gauss_db.SC WHERE C# = '" + courseId + "'");
                    rs.next();
                    int studentCount = rs.getInt("student_count");
                    rs.close();

                    if (studentCount < 300 && !assignedCourses.contains(courseId)) {
                        double grade = generateGrade(random);
                        try {
                            stmt.executeUpdate("INSERT INTO gauss_db.SC (S#, C#, GRADE) VALUES "
                                    + "('" + studentId + "', '" + courseId + "', " + grade + ")");
                            assignedCourses.add(courseId);
                            coursesAssigned++;
                        } catch (SQLException e) {
                            if (e.getSQLState().equals("23505")) {
                                // Duplicate key, skip this course and try another
                                continue;
                            } else {
                                throw e;
                            }
                        }
                    }
                }
            }

            System.out.println("Courses assigned to students successfully!");

        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (rs != null) {
                rs.close();
            }
        }
    }

    private static double generateGrade(Random random) {
        // Generate a grade with a mean of 80
        return 70 + random.nextGaussian() * 10;
    }

}
```

##### 3.2.4 SC数据生成

```java
package com.sxt;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

public class Courseselection2 {

    public static void main(String[] args) {
        System.out.println("Hello, World!");

        // Database connection parameters
        String url = "jdbc:postgresql://192.168.3.28:5432/mydb";
        String user = "java";
        String password = "xyx2003.";

        Connection conn = null;
        try {
            // Load the PostgreSQL driver (optional step in modern JDBC)
            Class.forName("org.postgresql.Driver");

            // Get a connection to the database
            conn = DriverManager.getConnection(url, user, password);
            System.out.println("Connection established successfully!");

            // Assign courses to students
            assignCoursesToStudents(conn);

        } catch (SQLException e) {
            System.out.println("SQL Exception: " + e.getMessage());
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.out.println("PostgreSQL JDBC Driver not found: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close the connection
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    System.out.println("Failed to close the connection: " + e.getMessage());
                }
            }
        }
    }

    private static void assignCoursesToStudents(Connection conn) throws SQLException {
        Statement stmt = null;
        ResultSet rs = null;
        List<String> studentIds = new ArrayList<>();
        List<String> courseIds = new ArrayList<>();
        Random random = new Random();

        try {
            stmt = conn.createStatement();
            // Get all student IDs
            rs = stmt.executeQuery("SELECT S# FROM gauss_db.S");
            while (rs.next()) {
                studentIds.add(rs.getString("S#"));
            }
            rs.close();

            // Get all course IDs
            rs = stmt.executeQuery("SELECT C# FROM gauss_db.C");
            while (rs.next()) {
                courseIds.add(rs.getString("C#"));
            }
            rs.close();

            // For each student, assign courses
            for (String studentId : studentIds) {
                // Check if the student already has course records
                rs = stmt.executeQuery("SELECT COUNT(*) AS course_count FROM gauss_db.SC WHERE S# = '" + studentId + "'");
                rs.next();
                int existingCourses = rs.getInt("course_count");
                rs.close();

                int coursesToAssign = existingCourses > 0 ? 20 : 40;
                System.err.println("course="+ coursesToAssign);
                Set<String> assignedCourses = new HashSet<>();
                int coursesAssigned = 0;

                while (coursesAssigned < coursesToAssign) {
                    String courseId = courseIds.get(random.nextInt(courseIds.size()));
                    System.out.println("courseId is "+courseId);
                    System.out.println(coursesAssigned+"//"+coursesToAssign);
                    // Check if the course already has 300 students
                    rs = stmt.executeQuery("SELECT COUNT(*) AS student_count FROM gauss_db.SC WHERE C# = '" + courseId + "'");
                    rs.next();
                    int studentCount = rs.getInt("student_count");
                    rs.close();

                    if (studentCount < 300 && !assignedCourses.contains(courseId)) {
                        double grade = generateGrade(random);
                        try {
                            stmt.executeUpdate("INSERT INTO gauss_db.SC (S#, C#, GRADE) VALUES "
                                    + "('" + studentId + "', '" + courseId + "', " + grade + ")");
                            assignedCourses.add(courseId);
                            coursesAssigned++;
                        } catch (SQLException e) {
                            if (e.getSQLState().equals("23505")) {
                                // Duplicate key, skip this course and try another
                                continue;
                            } else {
                                throw e;
                            }
                        }
                    }
                }
            }

            System.out.println("Courses assigned to students successfully!");

        } finally {
            if (stmt != null) {
                stmt.close();
            }
            if (rs != null) {
                rs.close();
            }
        }
    }

    private static double generateGrade(Random random) {
        // Generate a grade with a mean of 80
        return 70 + random.nextGaussian() * 10;
    }

}
```

##### 3.2.5 插入后的展示

![image-20240614094806049](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614094806049.png)

##### 3.2.6  SQL 语句实现，并分析其运行效率

​	1.**查询选修了 3 门以上课程（包括 3 门）的学生中平均成绩最高的同学学号及姓名。**

​	原查询：

![image-20240614101758432](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614101758432.png)

​	优化后的查询：

​		![image-20240614101954615](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614101954615.png)

​	优化后的查询思路：

**数据过滤和聚合**:

- 使用 `WITH` 子句定义一个名为 `FilteredStudents` 的临时结果集。

- 在 

  ```
  FilteredStudents
  ```

   中：

  - 从表 `S` 和 `SC` 进行连接，目的是获取学生信息以及他们的课程成绩。
  - 对每个学生 (`S.S#` 和 `S.SNAME` 组合) 进行分组。
  - 计算每个学生的平均成绩 `AVG(SC.GRADE)`。
  - 使用 `HAVING` 子句过滤出至少选修了3门课程的学生（`HAVING COUNT(SC.C#) >= 3`）。

**结果排序和选择**:

- 从 `FilteredStudents` 临时结果集中选择学生编号 (`S#`) 和学生姓名 (`SNAME`)。
- 按照平均成绩 (`AvgGrade`) 降序排列学生。
- 使用 `FETCH FIRST 1 ROW ONLY` 限制结果集只返回一行，即平均成绩最高的那位学生。

​	**2.查询未选修课程“CS-02”的女生学号及其已选各课程编号、成绩。**

​					（1）：使用原查询语句：

![image-20240614100052249](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614100052249.png)

​					（2）：使用修改后的sql语句：

![image-20240614100255566](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614100255566.png)



​		效率提高原因：

​	**`NOT IN` 子查询**：`NOT IN` 子查询在处理大数据集时效率低，因为它需要对外层查询的每一行都进行子查询。这种操作在数据量大时会非常耗时。

​	**`LEFT JOIN` 和 `IS NULL`**：使用 `LEFT JOIN` 加上 `IS NULL` 的方式，数据库可以通过一次性扫描和连接操作来完成查询，而不是对每一行进行子查询。`LEFT JOIN` 会首先连接两个表，并在连接后的结果集中查找 `SC2.S# IS NULL` 的行。

​	**减少子查询次数**：这种方法避免了对每个 `S` 表记录进行子查询，减少了查询次数。



​	**3.查询选修了计算机专业全部课程（课程编号为“CS-××”）的学生姓名及已获得的学分总数**

​	原始查询：

![image-20240614101135471](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614101135471.png)

优化后的查询：

​			![image-20240614101206225](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240614101206225.png)

分析：

**`JOIN` 替换 `LEFT JOIN` 和 `NOT EXISTS`**：

- 通过内连接 `JOIN` 替代 `LEFT JOIN` 和 `NOT EXISTS`，确保只查询存在的匹配记录。
- 这样做减少了数据库引擎处理左连接的开销。

**`HAVING COUNT`**：

- 使用 `HAVING` 子句来进行分组计数并对比，这样可以一次性获取符合条件的学生。
- `COUNT(DISTINCT C.C#)` 确保每个学生选修的独特课程数量与所有 `CS-` 开头的课程数量一致。



## 4、数据库的备份

和好友**申程宇**预先协商，都通过**openGauss提供的gs_dumpall方式备份各自数据库**，并发送对方进行恢复。

### 进行数据库的备份

```
mkdir -p /opt/software/openGauss/backup

/opt/software/openGauss/bin/gs_dumpall -f /opt/software/openGauss/backup/bkp1.sql

```

创建backup目录，然后使用gs_dumpall方式对数据库进行备份，保存为bkp1.sql文件。

![image-20240619155411596](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619155411596.png)

保存的文件：

![image-20240619213855432](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619213855432.png)

### 对搭档的数据库进行恢复

```
gsql -d postgres -p 5432 -f /opt/software/openGauss/backup/bkp_scy.sql
```

`gsql`：这是 OpenGauss 数据库系统的命令行客户端工具，用于连接和操作数据库。

`-d postgres`：

- `-d` 选项指定要连接的数据库名称。
- `postgres` 是要连接的数据库名称。 OpenGauss 安装中，默认数据库名称为 `postgres`。

`-p 5432`：

- `-p` 选项指定数据库服务器监听的端口号。
- `5432` 设置端口号为5432

`-f /opt/software/openGauss/backup/bkp_scy.sql`：

- `-f` 选项指定包含 SQL 命令的文件路径。
- `/opt/software/openGauss/backup/bkp_scy.sql` 保存的搭档的.sql文件的路径。

![image-20240619162421186](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619162421186.png)

### 恢复效果展示

![image-20240619163005701](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619163005701.png)

其中gauss_db模式下为原本自己的3个表，public下为搭档的3个表。

### 搭档表的合理性及数据质量

#### 表的设计

![image-20240619163149210](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619163149210.png)

![image-20240619163250288](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619163250288.png)

![image-20240619165515330](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619165515330.png)

搭档表中的每个条目的数据类型设计基本合理。

例如C表中的cname，虽然当前表内所有名字不会超过9个byte(3个汉字)，但是考虑到可能有少数民族或英文名等较长的人名，设置为varchar[30]合理。

**可以优化的地方**

C表中的period学时属性可以设置为int2，16字节，可以表示+-2^15,约为+-32000，表示课时已经足够了。

C表中的c#使用了char[10]，课程编号格式都为"XX-YY"，其中X和Y都可以用ASCII编码表示，所以理论上只需要char[5]就能表示所有的课程号，这里这样设计可能是预留几位提高鲁棒性。

#### 数据分析

##### C表：

![image-20240619173006433](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619173006433.png)

###### **优点**：

​	课时period分布均匀。课程名称规整，一名老师可以代多门课，符合实际。

###### **缺点**：

​	课时与学分分布不合理。大部分情况下学分与课时数应该成一定程度的正相关，这里出现了高学时低学分的情况，有些不合理

![image-20240619173630024](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619173630024.png)

![image-20240619173659844](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619173659844.png)

​	此外课程名复用的情况较多，一般情况下是可能有多门不同的课课程名相同，但这种情况较少。

##### S表：

![image-20240619173938464](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619173938464.png)

​	表中的各项数据均合理。

​	学号设置初始位为0，长度与一开始提供的已有的学号的学号相同都是8位，且第一位都为0。

​	姓名合理，符合人名规范。

​	出生日期合理，基本都是2000-2005出生，符合当前在校大学生年纪。

​	身高合理。女生平均身高低于男生平均身高，平均身高合理，身高分布合理，推测是使用的正态分布。

​	宿舍分配合理，男女住在不同的宿舍楼。

##### SC表

​	![image-20240619175425805](C:\Users\LeBlanC\AppData\Roaming\Typora\typora-user-images\image-20240619175425805.png)

成绩合理，最多保留到0.5符合实际。

## 5、实验心得

​	在本次数据库实验中，我完成了在本地安装OpenGauss数据库，并进行了相关数据管理的操作。首先，通过详细的文档和指南，我成功地在本地环境中安装并配置了OpenGauss数据库。这一步骤让我深入了解了数据库安装的各个环节，以及如何配置数据库参数以优化性能。随后，我使用Python编写了爬虫程序，从指定的网站爬取数据，并将这些数据存储到OpenGauss数据库的表中。这个过程让我掌握了爬虫技术和数据清洗的基本方法，以及使用JDBC将外部数据导入数据库。在实验中，我还设计了多种SQL查询，进一步增强了对SQL语法和数据库操作的理解。总体而言，这次实验不仅提升了我对数据库技术的实际操作能力，也加深了对数据管理和处理的认识，为以后的数据相关工作打下了坚实的基础。